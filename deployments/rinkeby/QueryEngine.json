{
  "address": "0x893e95095c5d26028474aD38DA98a2DfE25B27D0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "contractAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "script",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "inputLocations",
          "type": "uint256[]"
        }
      ],
      "name": "query",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "script",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "inputLocations",
          "type": "uint256[]"
        }
      ],
      "name": "queryAllPrices",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x508666242f5e42132f10794bb2c27684ff57d870e4fda9a93a1c57a526030c13",
  "receipt": {
    "to": null,
    "from": "0x4F8f512Dab59F227EA70B1D8A0044aFa95CC80C3",
    "contractAddress": "0x893e95095c5d26028474aD38DA98a2DfE25B27D0",
    "transactionIndex": 15,
    "gasUsed": "514161",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7f809c782970a28f80c9ec327f62b85e13566c8b84c5165192a8447df1311d7e",
    "transactionHash": "0x508666242f5e42132f10794bb2c27684ff57d870e4fda9a93a1c57a526030c13",
    "logs": [],
    "blockNumber": 8364132,
    "cumulativeGasUsed": "6135358",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "59536337a91024c932facfe596b5086e",
  "metadata": "{\"compiler\":{\"version\":\"0.7.4+commit.3f05b770\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"script\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"inputLocations\",\"type\":\"uint256[]\"}],\"name\":\"query\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"script\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"inputLocations\",\"type\":\"uint256[]\"}],\"name\":\"queryAllPrices\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getPrice(address,bytes)\":{\"params\":{\"contractAddress\":\"contract to query\",\"data\":\"the bytecode for the contract call\"},\"returns\":{\"_0\":\"price in bytes\"}},\"query(bytes,uint256[])\":{\"params\":{\"inputLocations\":\"index locations within the script to insert input amounts dynamically\",\"script\":\"the compiled bytecode for the series of function calls to get the final price\"},\"returns\":{\"_0\":\"last price as uint\"}},\"queryAllPrices(bytes,uint256[])\":{\"params\":{\"inputLocations\":\"index locations within the script to insert input amounts dynamically\",\"script\":\"the compiled bytecode for the series of function calls to get the final price\"},\"returns\":{\"_0\":\"all prices as bytes\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getPrice(address,bytes)\":{\"notice\":\"Calls the price function specified by data at contractAddress, returning the price as bytes\"},\"query(bytes,uint256[])\":{\"notice\":\"Makes a series of queries at once, returning the final price as a uint\"},\"queryAllPrices(bytes,uint256[])\":{\"notice\":\"Makes a series of queries at once, returning all the prices as bytes\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/QueryEngine.sol\":\"QueryEngine\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/QueryEngine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./lib/BytesLib.sol\\\";\\nimport \\\"./lib/CalldataEditor.sol\\\";\\n\\ncontract QueryEngine is CalldataEditor {\\n    // Allows easy manipulation on bytes\\n    using BytesLib for bytes;\\n\\n    /// @notice Calls the price function specified by data at contractAddress, returning the price as bytes\\n    /// @param contractAddress contract to query\\n    /// @param data the bytecode for the contract call\\n    /// @return price in bytes\\n    function getPrice(address contractAddress, bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = contractAddress.staticcall(data);\\n        require(success, \\\"Could not fetch price\\\");\\n        return returnData.slice(0, 32);\\n    }\\n\\n    /// @notice Makes a series of queries at once, returning all the prices as bytes\\n    /// @param script the compiled bytecode for the series of function calls to get the final price\\n    /// @param inputLocations index locations within the script to insert input amounts dynamically\\n    /// @return all prices as bytes\\n    function queryAllPrices(bytes memory script, uint256[] memory inputLocations) public view returns (bytes memory) {\\n        uint256 location = 0;\\n        bytes memory prices;\\n        bytes memory lastPrice;\\n        bytes memory callData;\\n        uint256 inputsLength = inputLocations.length;\\n        uint256 inputsIndex = 0;\\n        while (location < script.length) {\\n            address contractAddress = addressAt(script, location);\\n            uint256 calldataLength = uint256At(script, location + 0x14);\\n            uint256 calldataStart = location + 0x14 + 0x20;\\n            if (location != 0 && inputsLength > inputsIndex) {\\n                uint256 insertLocation = inputLocations[inputsIndex];\\n                replaceDataAt(script, lastPrice, insertLocation);\\n                inputsIndex++;\\n            }\\n            callData = script.slice(calldataStart, calldataLength);\\n            lastPrice = getPrice(contractAddress, callData);\\n            prices = prices.concat(lastPrice);\\n            location += (0x14 + 0x20 + calldataLength);\\n        }\\n        return prices;\\n    }\\n\\n    /// @notice Makes a series of queries at once, returning the final price as a uint\\n    /// @param script the compiled bytecode for the series of function calls to get the final price\\n    /// @param inputLocations index locations within the script to insert input amounts dynamically\\n    /// @return last price as uint\\n    function query(bytes memory script, uint256[] memory inputLocations) public view returns (uint256) {\\n        uint256 location = 0;\\n        bytes memory lastPrice;\\n        bytes memory callData;\\n        uint256 inputsLength = inputLocations.length;\\n        uint256 inputsIndex = 0;\\n        while (location < script.length) {\\n            address contractAddress = addressAt(script, location);\\n            uint256 calldataLength = uint256At(script, location + 0x14);\\n            uint256 calldataStart = location + 0x14 + 0x20;\\n            if (location != 0 && inputsLength > inputsIndex) {\\n                uint256 insertLocation = inputLocations[inputsIndex];\\n                replaceDataAt(script, lastPrice, insertLocation);\\n                inputsIndex++;\\n            }\\n            callData = script.slice(calldataStart, calldataLength);\\n            lastPrice = getPrice(contractAddress, callData);\\n            location += (0x14 + 0x20 + calldataLength);\\n        }\\n        return lastPrice.toUint256(0);\\n    }\\n}\",\"keccak256\":\"0x971d076cdf7227ee8456d0615024a341466b4489119dca66e681c928eb14cb89\",\"license\":\"MIT\"},\"contracts/lib/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity ^0.7.0;\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length), \\\"Read out of bounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= (_start + 20), \\\"Read out of bounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Read out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2), \\\"Read out of bounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4), \\\"Read out of bounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8), \\\"Read out of bounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12), \\\"Read out of bounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16), \\\"Read out of bounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\",\"keccak256\":\"0x6d70ec583c608b94cdb17170dfb447d5df4a657410c1c3f36c885fa71ee7ec39\",\"license\":\"Unlicense\"},\"contracts/lib/CalldataEditor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BytesLib.sol\\\";\\n\\nabstract contract CalldataEditor {\\n    using BytesLib for bytes;\\n\\n    /// @notice Returns uint from chunk of the bytecode\\n    /// @param data the compiled bytecode for the series of function calls\\n    /// @param location the current 'cursor' location within the bytecode\\n    /// @return result uint\\n    function uint256At(bytes memory data, uint256 location) pure internal returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(0x20, location)))\\n        }\\n    }\\n\\n    /// @notice Returns address from chunk of the bytecode\\n    /// @param data the compiled bytecode for the series of function calls\\n    /// @param location the current 'cursor' location within the bytecode\\n    /// @return result address\\n    function addressAt(bytes memory data, uint256 location) pure internal returns (address result) {\\n        uint256 word = uint256At(data, location);\\n        assembly {\\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\\n                          0x1000000000000000000000000)\\n        }\\n    }\\n\\n    /// @notice Returns the start of the calldata within a chunk of the bytecode\\n    /// @param data the compiled bytecode for the series of function calls\\n    /// @param location the current 'cursor' location within the bytecode\\n    /// @return result pointer to start of calldata\\n    function locationOf(bytes memory data, uint256 location) pure internal returns (uint256 result) {\\n        assembly {\\n            result := add(data, add(0x20, location))\\n        }\\n    }\\n    \\n    /// @notice Replace the bytes at the index location in original with new bytes\\n    /// @param original original bytes\\n    /// @param newBytes new bytes to replace in original\\n    /// @param location the index within the original bytes where to make the replacement\\n    function replaceDataAt(bytes memory original, bytes memory newBytes, uint256 location) pure internal {\\n        assembly {\\n            mstore(add(add(original, location), 0x20), mload(add(newBytes, 0x20)))\\n        }\\n    }\\n\\n    /// @dev Get the revert message from a call\\n    /// @notice This is needed in order to get the human-readable revert message from a call\\n    /// @param res Response of the call\\n    /// @return Revert message string\\n    function getRevertMsg(bytes memory res) internal pure returns (string memory) {\\n        // If the res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (res.length < 68) return 'Call failed for unknown reason';\\n        bytes memory revertData = res.slice(4, res.length - 4); // Remove the selector which is the first 4 bytes\\n        return abi.decode(revertData, (string)); // All that remains is the revert string\\n    }\\n}\",\"keccak256\":\"0xd9dd639cf35c8a7457a1fc126da4801f5ff79ce3267e1f46121b11516ae27265\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610856806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80638ac06f5014610046578063a363a0f31461016f578063e39e64de14610295575b600080fd5b6100fa6004803603604081101561005c57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561008657600080fd5b82018360208201111561009857600080fd5b803590602001918460018302840111600160201b831117156100b957600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295506103cd945050505050565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561013457818101518382015260200161011c565b50505050905090810190601f1680156101615780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100fa6004803603604081101561018557600080fd5b810190602081018135600160201b81111561019f57600080fd5b8201836020820111156101b157600080fd5b803590602001918460018302840111600160201b831117156101d257600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b81111561022457600080fd5b82018360208201111561023657600080fd5b803590602001918460208302840111600160201b8311171561025757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506104d7945050505050565b6103bb600480360360408110156102ab57600080fd5b810190602081018135600160201b8111156102c557600080fd5b8201836020820111156102d757600080fd5b803590602001918460018302840111600160201b831117156102f857600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b81111561034a57600080fd5b82018360208201111561035c57600080fd5b803590602001918460208302840111600160201b8311171561037d57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550610595945050505050565b60408051918252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b6020831061040d5780518252601f1990920191602091820191016103ee565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d806000811461046d576040519150601f19603f3d011682016040523d82523d6000602084013e610472565b606091505b5091509150816104c1576040805162461bcd60e51b8152602060048201526015602482015274436f756c64206e6f7420666574636820707269636560581b604482015290519081900360640190fd5b6104ce816000602061064d565b95945050505050565b60606000606080606060008651905060005b88518610156105885760006104fe8a8861070a565b9050600061050f8b89601401610736565b905060348801881580159061052357508385115b156105535760008b858151811061053657fe5b6020026020010151905061054b8d898361073e565b506001909301925b61055e8c828461064d565b955061056a83876103cd565b9650610576888861074a565b975081603401890198505050506104e9565b5092979650505050505050565b805160009081906060908190835b87518510156106365760006105b8898761070a565b905060006105c98a88601401610736565b90506034870187158015906105dd57508385115b1561060d5760008a85815181106105f057fe5b602002602001015190506106058c898361073e565b506001909301925b6106188b828461064d565b955061062483876103cd565b965081603401880197505050506105a3565b6106418460006107c7565b98975050505050505050565b60608183018451101561069c576040805162461bcd60e51b815260206004820152601260248201527152656164206f7574206f6620626f756e647360701b604482015290519081900360640190fd5b6060821580156106b757604051915060208201604052610701565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156106f05780518352602092830192016106d8565b5050858452601f01601f1916604052505b50949350505050565b6000806107178484610736565b600160601b6bffffffffffffffffffffffff1990911604949350505050565b016020015190565b60209182015192010152565b6060806040519050835180825260208201818101602087015b8183101561077b578051835260209283019201610763565b50855184518101855292509050808201602086015b818310156107a8578051835260209283019201610790565b508651929092011591909101601f01601f191660405250905092915050565b60008160200183511015610817576040805162461bcd60e51b815260206004820152601260248201527152656164206f7574206f6620626f756e647360701b604482015290519081900360640190fd5b5001602001519056fea26469706673582212200aa053080ca70e6ad96d6075e40a84be02e476cfd909e5605831f51791571ab464736f6c63430007040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80638ac06f5014610046578063a363a0f31461016f578063e39e64de14610295575b600080fd5b6100fa6004803603604081101561005c57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561008657600080fd5b82018360208201111561009857600080fd5b803590602001918460018302840111600160201b831117156100b957600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295506103cd945050505050565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561013457818101518382015260200161011c565b50505050905090810190601f1680156101615780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100fa6004803603604081101561018557600080fd5b810190602081018135600160201b81111561019f57600080fd5b8201836020820111156101b157600080fd5b803590602001918460018302840111600160201b831117156101d257600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b81111561022457600080fd5b82018360208201111561023657600080fd5b803590602001918460208302840111600160201b8311171561025757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506104d7945050505050565b6103bb600480360360408110156102ab57600080fd5b810190602081018135600160201b8111156102c557600080fd5b8201836020820111156102d757600080fd5b803590602001918460018302840111600160201b831117156102f857600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b81111561034a57600080fd5b82018360208201111561035c57600080fd5b803590602001918460208302840111600160201b8311171561037d57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550610595945050505050565b60408051918252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b6020831061040d5780518252601f1990920191602091820191016103ee565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d806000811461046d576040519150601f19603f3d011682016040523d82523d6000602084013e610472565b606091505b5091509150816104c1576040805162461bcd60e51b8152602060048201526015602482015274436f756c64206e6f7420666574636820707269636560581b604482015290519081900360640190fd5b6104ce816000602061064d565b95945050505050565b60606000606080606060008651905060005b88518610156105885760006104fe8a8861070a565b9050600061050f8b89601401610736565b905060348801881580159061052357508385115b156105535760008b858151811061053657fe5b6020026020010151905061054b8d898361073e565b506001909301925b61055e8c828461064d565b955061056a83876103cd565b9650610576888861074a565b975081603401890198505050506104e9565b5092979650505050505050565b805160009081906060908190835b87518510156106365760006105b8898761070a565b905060006105c98a88601401610736565b90506034870187158015906105dd57508385115b1561060d5760008a85815181106105f057fe5b602002602001015190506106058c898361073e565b506001909301925b6106188b828461064d565b955061062483876103cd565b965081603401880197505050506105a3565b6106418460006107c7565b98975050505050505050565b60608183018451101561069c576040805162461bcd60e51b815260206004820152601260248201527152656164206f7574206f6620626f756e647360701b604482015290519081900360640190fd5b6060821580156106b757604051915060208201604052610701565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156106f05780518352602092830192016106d8565b5050858452601f01601f1916604052505b50949350505050565b6000806107178484610736565b600160601b6bffffffffffffffffffffffff1990911604949350505050565b016020015190565b60209182015192010152565b6060806040519050835180825260208201818101602087015b8183101561077b578051835260209283019201610763565b50855184518101855292509050808201602086015b818310156107a8578051835260209283019201610790565b508651929092011591909101601f01601f191660405250905092915050565b60008160200183511015610817576040805162461bcd60e51b815260206004820152601260248201527152656164206f7574206f6620626f756e647360701b604482015290519081900360640190fd5b5001602001519056fea26469706673582212200aa053080ca70e6ad96d6075e40a84be02e476cfd909e5605831f51791571ab464736f6c63430007040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getPrice(address,bytes)": {
        "params": {
          "contractAddress": "contract to query",
          "data": "the bytecode for the contract call"
        },
        "returns": {
          "_0": "price in bytes"
        }
      },
      "query(bytes,uint256[])": {
        "params": {
          "inputLocations": "index locations within the script to insert input amounts dynamically",
          "script": "the compiled bytecode for the series of function calls to get the final price"
        },
        "returns": {
          "_0": "last price as uint"
        }
      },
      "queryAllPrices(bytes,uint256[])": {
        "params": {
          "inputLocations": "index locations within the script to insert input amounts dynamically",
          "script": "the compiled bytecode for the series of function calls to get the final price"
        },
        "returns": {
          "_0": "all prices as bytes"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getPrice(address,bytes)": {
        "notice": "Calls the price function specified by data at contractAddress, returning the price as bytes"
      },
      "query(bytes,uint256[])": {
        "notice": "Makes a series of queries at once, returning the final price as a uint"
      },
      "queryAllPrices(bytes,uint256[])": {
        "notice": "Makes a series of queries at once, returning all the prices as bytes"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}